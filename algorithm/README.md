# 算法

## 线性表
* 数组

* 链表

## 递归
递归在栈数据结构上的一系列逻辑操作，递归代码实际上是利用函数调用的系统栈，因此任何递归代码都可以使用栈非递归实现。

在小规模数据上，能利用递归代码就使用递归；由于系统对函数调用栈大小的限制，在大规模数据上，会出现栈溢出，因此使用非递归代码。

## 排序


## 回溯

## 动态规划
动态规划的思想是用空间换时间。

> 动态规划是用空间代价来缩减问题求解的时间复杂度。

## 图算法


## 单调栈


## 字符串匹配

## 分治
在分治策略中，我们递归地求解一个问题，在每层递归中应用三个步骤：
1. **分解**(Divide)将问题划分为一些子问题，子问题的形式与原问题一样，只是规模更小。  
2. **解决**(Conquer)递归地求解出子问题，如果子问题的规模足够小，则停止递归，直接求解。
3. **合并**(Combine)将子问题的解组合成原问题的解。

当子问题足够大，需要递归求解时，我们称之为**递归情况**。当子问题变得足够小，不再需要递归时，我们说递归已经“触底”，进入了**基本情况**。有时，除了与原问题形式完全一样的规模更小的子问题外，还需要求解与原问题不完全一样的子问题。我们将这些子问题的求解看做合并步骤的一部分。

> 分治法是一种稍微复杂的递归，分治法是用递归的方法缩减问题的规模。  
规模n -> 规模n-1 -> ... -> 规模1  
规模n <- 规模n-1 <- ... <- 规模1  
>> 常规的递归为：f(n) = g(f(n-1))  
分治的递归为：f(n) = g(f(m), f(n-m))  

## 算法导论

+ 排序
    - 冒泡排序
    - 选择排序
    - 插入排序
    - 希尔排序
    - 归并排序
    - 快速排序
    - 堆排序
    - 计数排序
    - 桶排序
    - 基数排序
+ 树算法
    - 二叉树的遍历
    - 哈弗曼树的编码与解码
    - 堆的构建与增删
    - 二叉搜索树的增删改查
    - AVL的增删改查
+ 图算法
    - 深度优先、广度优先遍历
    - 拓扑排序
    - 关键路径算法
    - 单源最短路径
        * Bellman-Ford算法
        * 有向无环图的单源最短路径
        * Dijkstra算法
    - 所有结点对的最短路径
        * Floyd算法
    - 最小生成树
        * Kruskal算法那
        * Prim算法
+ 分治策略
    - 最大子数组问题
+ 模式匹配
+ 高级设计与技术分析
    - 动态规划
        * 钢条切割
        * 矩阵链乘法
        * 动态规划原理
        * 最长公共子序列
        * 最优二叉搜索树
    - 贪心算法
        * 活动选择问题
        * 贪心算法原理
        * 赫夫曼编码
    - 摊还算法