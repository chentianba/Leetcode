# 算法

## 线性表
* 数组
* 链表
    * 单链表反转
    * 链表中环的检测
    * 两个有序的链表合并
    * 删除链表倒数第n个节点
    * 快慢指针
* 栈
    * 表达式求值
    * 括号匹配
* 队列
    * 顺序队列
    * 链式队列
    * 循环队列
    * 阻塞队列与并发队列

## 单调栈
单调栈就是栈内元素单调递增或者单调递减的栈。
1. 单调栈只能在栈顶操作
2. 栈内元素具有单调性
3. 单调栈的维护是**O(n)级的时间复杂度**，所有元素都只会进栈一次
4. 元素进栈时，它的左拓展区间能确定
5. 元素出栈时，它的右拓展区间能确定

## 递归
递归在栈数据结构上的一系列逻辑操作，递归代码实际上是利用函数调用的系统栈，因此任何递归代码都可以使用栈非递归实现。

在小规模数据上，能利用递归代码就使用递归；由于系统对函数调用栈大小的限制，在大规模数据上，会出现栈溢出，因此使用非递归代码。

## 排序
![排序算法](/algorithm/Sorting/sorting_summary.png)

## 回溯
递归与非递归

## 动态规划
动态规划的思想是用空间换时间。

> 动态规划是用空间代价来缩减问题求解的时间复杂度。

## 图算法
| 功能 | 方法 | 时间复杂度 | 简介
| --- | --- | :---: | :--- |
| 图的遍历 | [深度优先搜索DFS](#深度优先搜索) | - | 使用栈 |
| | [宽度优先搜索BFS](#宽度优先搜索) | - | 使用队列 |
| | [拓扑排序](#拓扑排序) | - | <li>选取入度为0的结点</li><li>删除该结点和其所有出边</li> |
| |　[关键路径算法](#关键路径) | - | <li>先拓扑排序</li><li>顺序求出最晚开始时间，再逆序求出最早开始时间</li><li>最晚、最早开始时间相等的就是关键活动</li> |
| 单源最短路径 | [Bellman-Ford算法](#Bellman-Ford算法) | O(VE) | <li>对所有边进行松弛操作，进行V-1次</li> <li>再对所有边进行第V次松弛判断，如果可以松弛，则存在负值环路</li>|
| | [有向无环图的单源最短路径](#有向无环图的单源最短路径) | O(V+E) | <li>先拓扑排序</li><li>按照拓扑序对每个顶点的出边执行松弛操作</li> |
| | [Dijkstra算法（优先队列）](#Dijkstra算法) | O((V+E)logV) | <li>从U(初始为V)中找出路径最短的结点u，加入到集合S中</li><li>对u的所有出边执行松弛操作</li><li>重复V次</li> |
| 所有结点对的最短路径 | [Floyd算法](#Floyd算法) | O(V^3) | 动态规划 |
| 最小生成树 | [Kruskal算法](#Kruskal算法) | O(VE) | <li>从边集合中找出权重最小的边</li><li>判断该边的两个顶点是否在同一连通分量中</li>|
| | [Prim算法](#Prim算法) | O(V^2) | <li>找到U(初始化为u0)和V-U之间权重最小的边<u,v></li><li>将v加入U中，重复V次</li> |

## 字符串匹配

## 分治
在分治策略中，我们递归地求解一个问题，在每层递归中应用三个步骤：
1. **分解**(Divide)将问题划分为一些子问题，子问题的形式与原问题一样，只是规模更小。  
2. **解决**(Conquer)递归地求解出子问题，如果子问题的规模足够小，则停止递归，直接求解。
3. **合并**(Combine)将子问题的解组合成原问题的解。

当子问题足够大，需要递归求解时，我们称之为**递归情况**。当子问题变得足够小，不再需要递归时，我们说递归已经“触底”，进入了**基本情况**。有时，除了与原问题形式完全一样的规模更小的子问题外，还需要求解与原问题不完全一样的子问题。我们将这些子问题的求解看做合并步骤的一部分。

> 分治法是一种稍微复杂的递归，分治法是用递归的方法缩减问题的规模。  
规模n -> 规模n-1 -> ... -> 规模1  
规模n <- 规模n-1 <- ... <- 规模1  
>> 常规的递归为：f(n) = g(f(n-1))  
分治的递归为：f(n) = g(f(m), f(n-m))  

## 算法导论

+ 排序
    - 冒泡排序
    - 选择排序
    - 插入排序
    - 希尔排序
    - 归并排序
    - 快速排序
    - 堆排序
    - 计数排序
    - 桶排序
    - 基数排序
+ 树算法
    - 二叉树的遍历
    - 哈弗曼树的编码与解码
    - 堆的构建与增删
    - 二叉搜索树的增删改查
    - AVL的增删改查
+ 图算法
    - 深度优先、广度优先遍历
    - 拓扑排序
    - 关键路径算法
    - 单源最短路径
        * Bellman-Ford算法
        * 有向无环图的单源最短路径
        * Dijkstra算法
    - 所有结点对的最短路径
        * Floyd算法
    - 最小生成树
        * Kruskal算法那
        * Prim算法
+ 分治策略
    - 最大子数组问题
+ 模式匹配
+ 高级设计与技术分析
    - 动态规划
        * 钢条切割
        * 矩阵链乘法
        * 动态规划原理
        * 最长公共子序列
        * 最优二叉搜索树
    - 贪心算法
        * 活动选择问题
        * 贪心算法原理
        * 赫夫曼编码
    - 摊还算法