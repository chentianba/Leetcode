# 动态规划

## 理论
动态规划的核心思想是用空间换时间，用空间保存中间计算状态，减少计算时间。

动态规划适合解决的问题的模型：**多阶段决策最优解模型**

动态规划的三个特征：
* 最优子结构：问题的最优解包含子问题的最优解，即后面阶段的状态可以通过前面阶段的状态推导出来。
* 无后效性：无后效性有两层含义，第一层含义是，在推导后面阶段的状态的时候，我们只关心前面阶段的状态值，不关心这个状态是怎么一步一步推导出来的。第二层含义是，某阶段状态一旦确定，就不受之后阶段的决策影响。
* 重复子问题：不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态。

分析步骤：
* 考虑用最直接的方法的计算规模
* （可选）通过某种转化，降低计算规模，如[Leetcode 464.Can I Win](https://leetcode.com/problems/can-i-win/)
* 构建该规模的空间结构（如二维数组等）保存计算的中间状态


## 贪心、分治、回溯和动态规划四种算法思想比较
贪心、回溯、动态规划可以归为一类，而分治单独可以作为一类，前三个算法解决问题的模型，都可以抽象成我们今天讲的那个多阶段决策最优解模型，而分治算法解决的问题尽管大部分也是最优解问题，但是，大部分都不能抽象成多阶段决策模型。

回溯算法是个“万金油”。基本上能用的动态规划、贪心解决的问题，我们都可以用回溯算法解决。回溯算法相当于穷举搜索。穷举所有的情况，然后对比得到最优解。不过，回溯算法的时间复杂度非常高，是指数级别的，只能用来解决小规模数据的问题。

尽管动态规划比回溯算法高效，但是，并不是所有问题，都可以用动态规划来解决。能用动态规划解决的问题，需要满足三个特征，最优子结构、无后效性和重复子问题。在重复子问题这一点上，动态规划和分治算法的区分非常明显。分治算法要求分割成的子问题，不能有重复子问题，而动态规划正好相反，动态规划之所以高效，就是因为回溯算法实现中存在大量的重复子问题。

贪心算法实际上是动态规划算法的一种特殊情况。它解决问题起来更加高效，代码实现也更加简洁。不过，它可以解决的问题也更加有限。它能解决的问题需要满足三个条件，最优子结构、无后效性和贪心选择性（这里我们不怎么强调重复子问题）。贪心选择性”的意思是，通过局部最优的选择，能产生全局的最优选择。每一个阶段，我们都选择当前看起来最优的决策，所有阶段的决策完成之后，最终由这些局部最优解构成全局最优解。

## 实践

动态规划一般分为这几类：
1. 最值型动态规划，比如求最大，最小值是多少，最大利润，最小数量，最长子串
2. 计数型动态规划，比如换硬币，有多少种换法，多少种路径
3. 坐标型动态规划，比如在m*n矩阵求最值型，计数型，一般是二维矩阵
4. 区间型动态规划，比如在区间中求最值 
5. 其他
    * 存在型（博弈型）：能否跳到最后一块石头，先手玩家必胜还是必败
    * 序列型：前i个元素的序列性质
    * 划分型：


参考[动态规划分类](https://blog.csdn.net/weixin_44424668/article/month/2020/01)分为如下几类：
1. 坐标型：给定网格、序列，来求满足某种性质的最大值、最小值
    * 机器人达到网格右下角的不同路径数
    * 数组中的最长上升连续子序列
    * 求最小路径和
2. 序列型：序列型dp就是序列+状态
    * 相邻房屋染不同颜色的费用
    * 小偷打劫房屋
    * 买卖股票的最佳时机
3. 划分型：给定长度为N的字符串，需要划分成若干段，段数不限，每一段满足一定的性质
    * 解码方法
    * 给定字符串 s, 需要将它分割成一些子串， 使得每个子串都是回文串，最少需要分割几次?
    * 书本分发
4. 博弈型
    * 先手玩家必胜还是必败
5. 背包型
    * 背包问题
6. 区间型：给定一个序列或字符串要进行一些操作，最后一步要将序列或字符串去头、去尾
    * 给一字符串 s,，找出在 s 中的最长回文子序列的长度
    * 攀爬字符串
    * 吹爆气球
7. 双序列型：就是有两个子序列/字符串，每个序列本身是一维的，可以转换为二维dp
    * 最长公共子序列
    * 交错字符串
    * 编辑距离

问题：
1. 编辑距离
    * 莱文斯坦距离
    * 最长公共子序列长度
2. 最长递增子序列
3. 背包问题
4. 资源分配