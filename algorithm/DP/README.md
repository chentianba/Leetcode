# 动态规划

## 理论
动态规划的核心思想是用空间换时间，用空间保存中间计算状态，减少计算时间。

动态规划适合解决的问题的模型：**多阶段决策最优解模型**

动态规划的三个特征：
* 最优子结构：问题的最优解包含子问题的最优解，即后面阶段的状态可以通过前面阶段的状态推导出来。
* 无后效性：无后效性有两层含义，第一层含义是，在推导后面阶段的状态的时候，我们只关心前面阶段的状态值，不关心这个状态是怎么一步一步推导出来的。第二层含义是，某阶段状态一旦确定，就不受之后阶段的决策影响。
* 重复子问题：不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态。

分析步骤：
* 考虑用最直接的方法的计算规模
* （可选）通过某种转化，降低计算规模，如[Leetcode 464.Can I Win](https://leetcode.com/problems/can-i-win/)
* 构建该规模的空间结构（如二维数组等）保存计算的中间状态


## 贪心、分治、回溯和动态规划四种算法思想比较
贪心、回溯、动态规划可以归为一类，而分治单独可以作为一类，前三个算法解决问题的模型，都可以抽象成我们今天讲的那个多阶段决策最优解模型，而分治算法解决的问题尽管大部分也是最优解问题，但是，大部分都不能抽象成多阶段决策模型。

回溯算法是个“万金油”。基本上能用的动态规划、贪心解决的问题，我们都可以用回溯算法解决。回溯算法相当于穷举搜索。穷举所有的情况，然后对比得到最优解。不过，回溯算法的时间复杂度非常高，是指数级别的，只能用来解决小规模数据的问题。

尽管动态规划比回溯算法高效，但是，并不是所有问题，都可以用动态规划来解决。能用动态规划解决的问题，需要满足三个特征，最优子结构、无后效性和重复子问题。在重复子问题这一点上，动态规划和分治算法的区分非常明显。分治算法要求分割成的子问题，不能有重复子问题，而动态规划正好相反，动态规划之所以高效，就是因为回溯算法实现中存在大量的重复子问题。

贪心算法实际上是动态规划算法的一种特殊情况。它解决问题起来更加高效，代码实现也更加简洁。不过，它可以解决的问题也更加有限。它能解决的问题需要满足三个条件，最优子结构、无后效性和贪心选择性（这里我们不怎么强调重复子问题）。贪心选择性”的意思是，通过局部最优的选择，能产生全局的最优选择。每一个阶段，我们都选择当前看起来最优的决策，所有阶段的决策完成之后，最终由这些局部最优解构成全局最优解。

## 实践

动态规划一般分为这几类：
1. 最值型动态规划，比如求最大，最小值是多少
2. 计数型动态规划，比如换硬币，有多少种换法
3. 坐标型动态规划，比如在m*n矩阵求最值型，计数型，一般是二维矩阵
4. 区间型动态规划，比如在区间中求最值 

问题：
1. 编辑距离
    * 莱文斯坦距离
    * 最长公共子序列长度
2. 最长递增子序列