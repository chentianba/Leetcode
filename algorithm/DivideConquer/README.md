# 分治

## 理论
分治算法（divide and conquer）的核心思想其实就是四个字，分而治之 ，也就是将原问题划分成n个规模较小，并且结构与原问题相似的子问题，递归地解决这些子问题，然后再合并其结果，就得到原问题的解。**分治算法是一种处理问题的思想，递归是一种编程技巧**。实际上，分治算法一般都比较适合用递归来实现。

分治算法能解决的问题，一般需要满足下面这几个条件：
* 原问题与分解成的小问题具有相同的模式；
* 原问题分解成的子问题可以独立求解，子问题之间没有相关性，这一点是分治算法跟动态规划的明显区别；
* 具有分解终止条件，也就是说，当问题足够小时，可以直接求解；
* 可以将子问题合并成原问题，而这个合并操作的复杂度不能太高，否则就起不到减小算法总体复杂度的效果了。

****

在分治策略中，我们递归地求解一个问题，在每层递归中应用三个步骤：
1. **分解**(Divide)将问题划分为一些子问题，子问题的形式与原问题一样，只是规模更小。  
2. **解决**(Conquer)递归地求解出子问题，如果子问题的规模足够小，则停止递归，直接求解。
3. **合并**(Combine)将子问题的解组合成原问题的解。

当子问题足够大，需要递归求解时，我们称之为**递归情况**。当子问题变得足够小，不再需要递归时，我们说递归已经“触底”，进入了**基本情况**。有时，除了与原问题形式完全一样的规模更小的子问题外，还需要求解与原问题不完全一样的子问题。我们将这些子问题的求解看做合并步骤的一部分。

> 分治法是一种稍微复杂的递归，分治法是用递归的方法缩减问题的规模。  
规模n -> 规模n-1 -> ... -> 规模1  
规模n <- 规模n-1 <- ... <- 规模1  
>> 常规的递归为：f(n) = g(f(n-1))  
分治的递归为：f(n) = g(f(m), f(n-m))  

## 分治问题

1. 二维平面上有n个点，如何快速计算出两个距离最近的点对？
2. 有两个n\*n的矩阵A，B，如何快速求解两个矩阵的乘积C=A\*B？
3. 求一组数据的有序对个数或者逆序对个数
