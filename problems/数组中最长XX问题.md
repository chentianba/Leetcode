# 数组中最长XX问题

|      问题        |   描述   | 解法 |
| :---------------: | :------------------------------------: | :---------------------: |
| 连续数组的最大和 | [-2,1,-3,4,-1,2,1,-5,4] --> [4,-1,2,1] |     动态规划            |
| 最长公共子串     | "aqbc"和"abcdf" --> "bc"               | 动态规划              |
| 最长公共子序列   | "aqbc"和"abcdf" --> "abc"              | 动态规划              |
| 最长上升子序列   | [1,3,5,4,7] --> [1,3,4,7]              | 动态规划/贪心+二分查找 |
| 最长连续子序列   | [100,4,200,1,3,2] --> [1,2,3,4]        |      并查集/线段合并         |
| 最长连续递增序列 | [1,3,5,4,7] --> [1,3,5]                | 滑动窗口              |


注：

* 公共子序列与公共子串不同在于子序列不要求连续，如"AC"是"ABCDEFG"的子序列，而不是子串，而"ABC"则是其子串。

## 连续数组的最大和
方法：**动态规划**

思路：假设以`i`结尾的子序列的最大和为`f(i)`，初始化时，`f(i) = nums[0]`，转移方程为`f(i) = max{f(i-1) + nums[i], nums[i]}`

## 最长公共子串
方法：**动态规划**

思路：假设以`i`和`j`结尾子串的最长公共子串的长度为`f(i,j)`，初始化时，`f(i,0) = 0, 0 <= i <= m`, `f(0,j) = 0, 0 <= j <= n`
* 当`s1[i]`和`s2[j]`相等时，`f(i,j) = 1 + f(i-1,j-1)`
* 当`s1[i]`和`s2[j]`不等时，`f(i,j) = 0`

最终结果是`f(i, j)`中的最大值


## 最长公共子序列
方法：**动态规划**

思路：假设以`i`和`j`结尾子串的最长公共子序列的长度为`f(i,j)`，初始化时，`f(i,0) = 0, 0 <= i <= m`, `f(0,j) = 0, 0 <= j <= n`
* 当`s1[i]`和`s2[j]`相等时，`f(i,j) = 1 + f(i-1,j-1)`
* 当`s1[i]`和`s2[j]`不等时，`f(i,j) = max{ f(i-1,j), f(i,j-1) }`

最终结果是`f(m, n)`


## 最长上升子序列
### 方法：**动态规划**

思路：假设以`i`结尾的递增子序列的长度为`f(i)`，初始化时，`f(i) = 0`；对`f(i)`，状态转移方程为`f(i) = max{f(j)} + 1, j < i and j >= 0 and nums[j] < nums[i]`。

### 方法：**贪心+二分查找**
思路：找到每个递增子序列长度对应的结尾元素，将每个长度的结尾元素更新为最小值，假设`a[j]`存储长度为`j+1`的序列结尾元素，则
* 对元素`nums[i]`，使用二分查找找到小于`nums[i]`的最后一个元素的位置`a[j]`
* 如果`a[j+1]`不存在，则更新`a[j+1] = nums[i]`
* 如果`a[j+1]`存在且`a[j+1] > nums[i]`，则更新`a[j+1] = nums[i]`


## 最长连续子序列
方法：**并查集**

思路：考虑时，
* 并查集：各个元素的按照是否连接分成不同类别
* 合并线段：可以将每个元素看做一个线段，最长连续子序列就是各个线段合并后的最长线段长度

在实现时，需要检查当前元素是否可以和过去的连续序列（线段）合并，使用哈希表存储查找时间复杂度为`O(1)`，每次合并一个元素，需要更新新形成线段的两个端点
```java
HashMap<Integer, Integer> hm = new HashMap<>();
int maxVal = 1;
for (int i = 0; i < nums.length; ++i) {
    if (!hm.containsKey(nums[i])) {
        int left = hm.getOrDefault(nums[i]-1, 0);
        int right = hm.getOrDefault(nums[i]+1, 0);
        hm.put(nums[i], left + right + 1);
        hm.put(nums[i] - left, left + right + 1);
        hm.put(nums[i] + right, left + right + 1);
        maxVal = Math.max(maxVal, left+right+1);
    }
}
return maxVal;
```


## 最长连续递增序列（最长递增子数组）
方法：**滑动窗口**

思路：在一个连续递增子序列中，会有`nums[i-1] < nums[i]`，因此遍历整个数组，维持一个子数组递增的滑动窗口，记录其中的最大窗口
```java
int left = 0, cur = 0, maxLen = 1;
for (cur = 1; cur < nums.length; ++cur) {
    if (nums[cur] <= nums[cur-1]) left = cur;
    maxLen = Math.max(maxLen, cur - left + 1);
}
return maxLen;
```
